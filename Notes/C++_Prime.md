# Prime
---
### 一、内存分区

C++程序在执行时，可以将内存划分为4个区域： 
**代码区：**存放函数体的二进制代码，由操作系统进行管理的 
**全局区：**存放全局变量和静态变量以及常量 
**栈区：**由编译器自动分配释放, 存放函数的参数值,局部变量等 
**堆区：**由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 

#### 运行前：

在程序编译后，生成了exe可执行程序，未执行该程序前存在**代码区**和**全局区** 。 
**代码区：** 
其中代码区存放了CPU执行的机器指令。代码区拥有**共享**（内存中只需要有一份代码）和**只读**（不可以被修改）两个特点。 
**全局区：** 
全局区存放了**全局变量**和**静态常量**和**常量**。该区域的数据在程序结束后由操作系统释放。 
**Notes:** 
1、只要在函数中定义的变量（包括const修饰的局部变量）都是**局部变量**，保存在**栈**中，与常量区的内容存储区域不同；
2、在变量前有`static`属于**静态变量**；
3、在函数外定义的变量称为**全局变量** ；
4、**常量** 包括**字符串常量**和**const修饰的全局变量** 。

#### 运行后：
**栈区：**
由编译器自动分配释放，存放函数的参数值（形参），局部变量等。注意不能返回局部变量的地址，因为局部变量存放在栈区，在函数执行完后会自动释放。 
**堆区：**
由程序员开辟和释放，若程序不释放，程序结束后由操作系统自动回收。C++中利用new开辟内存。

#### new操作符的使用：
语法：`数据类型 *a = new 数据类型<与前相同>（数据）`
注意new返回的是该数据对应的类型的地址，所以需要用一个指针来接收它。
如在函数中定义`int* p = new int(10);`实际上指针p属于局部变量且保存在栈中，但由p指向的数据保存在堆区。 

---

### 二、引用 

语法：`数据类型 &别名 = 原名` 
此时别名称为原名的引用
**Notes:** 
1、引用必须进行初始化: `int &b = a`，并且不能分成两步：`int &b` + `b = a`； 
2、引用一旦初始化，就不能被修改；
3、引用必须引用合法的内存空间（不能是常量）。

#### 1、引用做函数参数： 

函数的参数传递包括：**值传递、地址传递、引用传递** 

各种传递方法的特点：
1、使用引用传递可以**简化指针**。**引用传递** 是在给实参起 **别名**，它没有自己的存储数据的内存位置，它访问的是另一个变量的内存地址。对引用变量作出的任何更改，实际上都是对它所引用的变量内存位置中存储数据的更改；
2、值传递：形参不会修饰实参；
3、地址传递和引用传递：形参可以修饰实参（含义见下）

**值传递：**

当信息被传递给一个函数时，采用按值传递的方式，这意味着**形参接收的是传递给它的值的副本**。如果形参的值在函数内部被改变，那么它对原始实参是没有影响的。
这说明：**形参变量在内存中的存储位置与原始实参的存储位置是分开的。**  

##### 引用传递：
引用变量： `int &b =a` 
引用数组： `int (&b)[sizeof(a)/sizeof(a[0])] = a` 
令b是a的引用，该操作实际上是让b作为a的别名，也就是让a和b都指向同一片内存单元。 
引用变量是变量的另一个别名，它没有自己的存储数据的内存位置，它访问的是另一个变量的内存地址。 
当使用引用变量作为形参时，它将变为实参列表中相应变量的别名，对形参进行的任何更改都将真正更改正在调用它的函数中的变量。 
**Notes:** 
1、引用必须声明时就要有初始化，如`int &b`会报错 
2、引用初始化的变量一定要能取地址，如`int &a = 10`10是常量不能被引用，除非用const组成常引用:`const int &a = 10`  
3、引用不可中途改变 
4、值传递和引用传递的区别：
值传递（pass-by-value）过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间来存放由主调函数放进来的**实参的值**，从而成为了**实参的一个副本**。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值；引用传递（pass-by-reference）过程中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但这时存放的是**由主调函数放进来的实参变量的地址**。被调函数对形参的任何操作都被处理成**间接寻址**，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做任何的操作都影响了主调函数中的实参变量。

##### 地址传递（指针传参）：
指针传参中被调函数的指针变量在栈内存中重新申请内存
e.g.

```
void swap(int *a, int *b)  // 通过*读门牌号里面的内容
{
    int c = 0;
    c = *a;
    *a = *b;
    *b = c;
}
int main()
{
    int a = 20;
    int b = 30;
    printf("a is %d, b is %d\n", a, b); // 20 30
    swap(&a, &b); // 将a和b的门牌号传递过去
    printf("now, a is %d, b is %d\n", a, b); // 30 20
}
```



#### 2、引用做函数返回值： 

**Notes：** 
1、不能返回局部变量的引用； 
2、如果函数值的返回值是引用，则函数的调用可以作为左值。

#### 3、引用本质： 
引用的本质是在c++内部实现一个**指针常量**用以表现变量的别名这一特性：
当遇到 `int& ref = a` 编译器会自动转换为 `int* const ref = &a`，即**将引用ref设置为一个指针常量并指向被引用的变量，保存该变量的地址，且指针的指向不可以被修改** 
遇到 `ref = 20`时，编译器自动转换为`*ref = 20`，即**将出现的引用ref自动解引用，并获取被引用变量地址所存放的值**  

#### 4、常量引用：
作用：常量引用通过const修饰形参，防止形参改变实参
**语法：const 引用类型& 引用 = 常量**
如，`const int& ref = 10;` 编译器自动修改为 `int temp = 10; int& ref =temp;`



---



## 三、函数提高



#### 1、默认参数
**Notes:** 
1、如果某个位置已经有了默认参数，则这个位置往后都必须有默认参数 
2、如果函数声明和实现其中只有一个能有默认参数 

#### 2、占位参数 
**语法： 返回值类型 函数名（数据类型）{}** 
**Notes:** 
1、占位参数可以有默认参数 
2、主要用于函数重载

#### 3、函数重载
**作用：** 
函数名可以相同，提高复用性 
**条件：** 
（1）必须在同一个作用域下（都在全局作用域或同一类）； 
（2）函数名相同； 
（3）函数参数类型不同，或者个数不同，或者顺序不同。 
**Notes:** 
1、（重要）函数值的返回不可以作为函数重载的条件； 
2、引用作为函数重载的条件（形参分别是引用和常量引用）满足函数重载条件； 
3、函数重载遇到默认参数，如果调用函数出现二义性，则会报错。



---



## 四、类和对象



C++面向对象的三大特性：**封装、继承、多态** 
C++认为：万事万物都是对象，对象上有其属性和行为 
具有相同性质的对象，我们可以抽象为**类** 

#### 1、封装 
**语法：class 类名{ 访问权限1：属性/行为 访问权限2：...}** 
在设计类时，属性和行为写在一起： 
（1）类中的属性和行为，我们统一称为**成员** 
（2）类中的属性：成员属性/成员变量 
（3）类中的行为：成员函数/成员方法  

**访问权限：** 
**公共权限(public)、保护权限(protected)、私有权限(private)** 

**Notes:** 
1、三种访问权限的区别： 
公共权限：类内和类外都可以访问 
保护权限和私有权限：类内可以访问，类外不可以访问。子类可以继承保护权限的内容，但不可以继承私有权限的内容； 
2、struct和class两者类似，但默认的访问权限不同，struct中默认为公共，class默认为私有； 
3、我们通常将成员属性设置为私有，首先可以自己控制读写的权限（添加一些public的读写接口），其次对于写权限，我们可以检测数据的有效性； 
4、我们可以先声明一个类，在之后再进行定义。 

##### 案例：立方体类  
**Note:** 
判断两个立方体是否相等，有两种方式：全局函数和成员函数 
全局函数的方法利用引用传递分别传入两个立方体(&c1,&c2)，再对这两个立方体的属性进行判断。
成员函数的方法只需引用传递一个立方体(&c)，对这个立方体的属性和该成员函数所在的实例的属性(利用get获取)进行判断。

##### 案例：点和圆类
**Notes:** 
1、在类中可以让另一个类作为本类中的成员 
2、可以将一个类拆成两部分，将类的定义，包括类的权限、类的函数声明、类的属性写在头文件中；再将各方法以"全局函数"的形式写在源文件中，在函数前加 **类名::** 表示该方法作用域在该类中。 
e.g. 点类的头文件(注意圆类的头文件出现Point，需要再包含点类的头文件表示该类存在)

```
#pragma once
class Point {
private:
	int m_x;
	int m_y;
public:
	void set_x(int x);
	void set_y(int y);
	int get_x();
	int get_y();
};
```
e.g. 点类的源文件（注意要包含点类的头文件）
```
#include "point.h"
#include <iostream>
using namespace std;

void Point::set_x(int x) {
	m_x = x;
}
void Point::set_y(int y) {
	m_y = y;
}
int Point::get_x() {
	return m_x;
}
int Point::get_y() {
	return m_y;
}
```

#### 2、对象的初始化和清理
#### 2.1 构造函数和析构函数 

构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 
析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。
c++利用了构造函数和析构函数完成对象初始化和清理工作，这两个函数将会被编译器自动调用。 
对象的初始化和清理工作是编译器强制要做的事情，因此如果我们不提供构造和析构，编译器会自动提供。编译器提供的构造函数和析构函数是空实现。

**构造函数：** 
构造函数语法：`类名(){} ` 
**Notes:** 
1、构造函数，没有返回值也不写void 
2、函数名称与类名相同
3、构造函数可以有参数，因此可以发生重载 
4、程序在**调用对象**时候会自动调用构造，无须手动调用,而且只会调用一次 

**析构函数：**
析构函数语法：`~类名(){ }`
一般当构造函数中出现new创建在堆上的内存，需要在析构函数中利用delete手动释放空间。其余情况，可以使用默认析构函数。
**Notes:** 
1、析构函数，没有返回值也不写void 
2、函数名称与类名相同，只需要在名称前加上符号 ~ 
3、析构函数不可以有参数，因此不可以发生重载 
4、程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次 

#### 2.2 构造函数的分类和调用

##### 分类：
按参数分：无参构造（默认构造） 有参构造 
按类型分：普通构造 拷贝构造

##### 调用方法：

**1、括号法：**

```
Test t1;//调用默认构造函数
Test t1();//error，编译器认定为声明
Test t2(10);//调用参数构造函数
Test t3(t2);//调用拷贝构造函数
```
调用默认构造函数时，不要加()，如Test t1()，编译器会认为这是一个函数的声明。 

**2、显示调用法：**

```
Test t1 = Test();//默认构造
Test t2 = Test(10);//有参构造，我们称Test(10)为匿名对象，当前行执行结束后，系统会立刻回收该对象 
Test t3 = Test(t2);//拷贝构造
```
不要利用拷贝构造函数初始化匿名对象，如Test(t3)，编译器会认为这是一个对象的声明。

**3、隐式转换法（编译器自动转换为显式法）：**
```
Test t4 = 10;//相当于Test t4 = Test(10) 有参构造
Test t5 = t4;//相当于Test t5 = Test(t4) 拷贝构造
```

#### 2.3 拷贝构造函数的调用情况： 
拷贝构造函数语法：`类名(const 类名& 被拷贝的对象){} `  
构造函数的调用：`类名 拷贝对象(被拷贝的对象)` 

**1、使用一个已经创建完毕的对象来初始化一个新对象（常用）**  

```
	Test a;
	Test b(a);
```
**2、值传递的方式给函数参数传值** 
```
void doWork1(Test t){}//值传递，创建一个Test类的副本t，如果在函数内改变t的属性，不会改变test1中的t
void test1() {
	Test t;
	doWork1(t);
}
```
**3、以值方式返回局部对象** 

```
Test doWork2() {
	Test t;
	cout << "doWork中的t地址为" << (int*)&t << endl;//此处t的地址是利用默认构造函数创建的t的地址
	return t;
}
//先调用拷贝构造函数创建一个t的副本用作值方式返回，之后自动调用析构函数依次释放该副本和doWork2中的t
void test2() {
	Test t = doWork2();//将返回值赋值给t时调用拷贝构造
	cout << "test2中的t地址为"<<(int*)&t << endl;//此处t的地址为利用拷贝构造函数创建t副本的地址
}
```

#### 2.4 构造函数的调用规则：
默认情况下，c++编译器至少给一个类添加3个函数 
1．默认构造函数（无参，函数体为空） 
2．默认析构函数（无参，函数体为空） 
3．默认拷贝构造函数，对(所有)属性进行值拷贝 

**Notes:**  
1、如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造 
2、如果用户定义拷贝构造函数，c++不会再提供其他构造函数 
3、可以先声明一个构造函数，在类外再进行实现（添加构造函数的作用域）。

#### 2.5 深拷贝和浅拷贝：
浅拷贝：简单的赋值拷贝操作（默认拷贝构造函数是浅拷贝） 
深拷贝：在堆区重新申请空间，进行拷贝操作 
**Notes:** 
1、如果利用编译器提供的拷贝构造函数，会做浅拷贝操作，浅拷贝的问题在于析构函数对于堆区的内存会**重复释放** ；  
2、为防止堆区重复释放，要自己编写拷贝构造函数实现**深拷贝**；  
3、当遇到堆区开辟内存时，析构函数需要对开辟的内存进行释放。

#### 2.6 利用初始化列表初始化属性：
用于给非静态成员变量初始化 
语法：`Constructor()：arribute1(value1),attribute2(value2)...{...}` 
e.g.: 
```
//将类成员变量分别用a,b,c来赋值
Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}
```
**Notes:** 
1、使用初始化列表初始化属性又称为显式初始化； 
2、C++ 初始化类成员时，是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序； 
3、必须用带有初始化列表的构造函数的情形： 
(1)成员类型是没有默认构造函数的类。若没有提供显式初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。 
(2)const 成员或引用类型的成员。因为 const 对象或引用类型只能初始化，不能对他们赋值。 

#### 2.7 类对象作为类成员： 
**Notes:** 
当其他类的对象作为本类的成员： 
1、在构造本类的对象会先构造其他类的对象，在构造自身； 
2、析构函数先释放自身的构造函数，再释放其它类的对象（后构造先析构，先构造后析构）  
3、定义类对象时，编译器直接为其分配内存；但若用其他类的指针作为本类的成员，编译器不为其分配内存，只有在构造函数中用new初始化后才分配，且为内存堆；

#### 2.8 静态成员:
静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 
静态成员分为：静态成员变量和静态成员函数

##### 静态成员变量:  
静态成员变量有两种访问方式：通过对象访问`p.a`、通过类名访问`Person::a` 
**Notes:**  
1、静态成员变量不属于某个对象，所有对象共享同一份数据 
2、在编译阶段分配内存 (静态成员变量位于全局区) 
3、类内声明:`static int atrribute`，类外初始化:`int ClassName::attribute = value` 
4、类外访问不到私有静态成员变量  

##### 静态成员函数：
静态成员函数有两种访问方式：通过对象访问`p.func()`、通过类名访问`Person::func()`  
**Notes:** 
1、所有对象共享同一个函数 
2、静态成员函数只能访问静态成员变量，而不可以访问非静态成员变量 
4、类外访问不到私有静态成员函数  

#### 2.9 类指针：
类指针是一个内存地址值，它指向内存中存放的类对象  
**Notes:** 
1、只有执行new后才会分配内存，且为内存堆。 
2、访问指向类的指针的成员，需要使用成员访问运算符->；  
3、在使用指针之前，必须用new对指针进行初始化:Test* t1 = new Test()。  

**类指针和类对象的区别：** 
作用基本一样 用途都是为了调用类的成员变量和成员函数； 
当希望明确使用这个类的时候，最好使用对象；  
如果希望使用C++中的动态绑定，则最好使用指针或者引用，指针和引用用起来更灵活，容易实现多态等。 



### 3、C++对象模型和this指针
#### 3.1 成员变量和成员函数分开存储
C++中类内的成员变量和成员函数分开存储 
**Notes:** 
1、非静态成员变量占对象空间，静态成员变量不占对象空间； 
2、空对象占用内存空间为1个字节，C++编译器会给每个空对象分配一个字节的空间，用于区分空对象占内存的位置；每个空对象应该有一个独一的内存地址； 

#### 3.2 this指针
由于每一个非静态成员函数只会产生一份函数实例，多个同类型的对象会共用同一块代码，this指针用于区分是哪个对象调用了自己。**this指针指向 被调用的成员函数 所属的对象** 

**使用场景：** 
1、当形参和成员变量同名时，为解决名称冲突， 可以用this指针区分； 
2、在类的非静态成员函数中返回对象本身，可使用return *this

**Notes:** 
1、this指针是隐含每一个非静态成员函数中的一种指针； 
2、this指针不需要定义，直接使用即可；  
3、当我们使用类成员变量时，编译器自动会在变量前加上this-> 
4、this指针的本质是一个指针常量:`类名* const this`，指针的指向不可以被修改

#### 3.3 空指针访问成员函数 
在C++的类中，当我们使用类成员变量时，编译器自动会在变量前加上this->，因此如果对象所指向的地址为NULL，会报错而无法访问类的成员函数 
添加：`if(this == NULL) return; `可以增强代码的健壮性。 

#### 3.4 const修饰成员函数
##### 常函数
成员函数后加const后我们称为这个函数为常函数；
语法：`函数返回值类型 函数名() const` 
const是在修饰this指针，表示this指针既不可以修改指针的指向，又不可以修改指针指向的值 
**Notes:** 
1、常函数内不可以修改成员属性（this指向的值）； 
2、成员属性声明时加关键字mutable后，在常函数中依然可以修改。 

##### 常对象
声明对象前加const称该对象为常对象 
语法：`const 类名 对象名` 
**Notes:** 
1、常对象只能调用常函数  
2、成员属性声明时加关键字mutable后，在常对象中依然可以修改。

### 4、友元
友元的目的就是让一个函数或者类访问另一个类中私有成员。 
友元函数可以让本不属于该类的成员函数有权利访问这个类的私有成员或是保护成员。
友元的三种实现：全局函数做友元、类做友元、成员函数做友元 
**Notes:**  
1、**定义**在类中的友元函数,其作用域在全局作用域下，没有在类中的友元声明之前声明的友元函数,其作用域则在第一个包围类的非类作用域下；  
2、友元类应该在拥有私有属性且允许被外界访问的那个类中进行声明，意思就是让别的类来访问自己的私有成员。

**全局函数做友元:**
```
friend void goodguy(Building* building);
```
**类做友元:**
```
//GoodGay是本类的友类，可以访问Building类的私有内容
friend class GoodGay;
```
**成员函数做友元:**
```
friend void goodGay::visit();
```

### 5、运算符重载
对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 
格式： 
```
/*类名*/ operator /*要重载的运算符*/()；//函数声明 
/*类名*/ /*类名*/::operator /*要重载的运算符*/() //函数主体  
{ 
  //具体操作 
}
```

**Notes:** 
1、若使用全局函数重载运算符，则一般在类中声明该运算符重载函数是友元函数；  
2、采用全局函数能使我们定义这样的运算符，它们的参数具有逻辑的**对称性** ； 
3、把运算符定义为成员函数能够保证在调用时对第一个（最左的）运算对象不出现类型转换，也就是**C++ 不会对调用成员函数的对象进行类型转换** ； 
4、有一部分运算符重载既可以是成员函数也可以是全局函数，虽然没有一个必然的、不可抗拒的理由选择成员函数，但我们应该优先考虑成员函数，这样更符合运算符重载的初衷； 
5、C++ 规定，箭头运算符->、下标运算符[]、函数调用运算符()、赋值运算符=只能以成员函数的形式重载。


#### 5.1 加号运算符重载
作用：实现两个自定义数据类型相加的运算。 
e.g.
```
Person operator+(Person& p) {...}//成员函数重载+号
Person operator+(Person& p1,Person& p2) {...}//全局函数重载+号
Person operator+(Person& p, int a){...}//运算符重载 可以发生函数重载
```
**Notes:** 
1、成员函数重载的本质：Person p3 = p1.operator+(p2);  
2、全局函数重载的本质：Person p3 = operator+(p1, p2);  
3、运算符重载可以发生函数重载；  
4、最好要以全局函数的形式重载+，这是为了保证+运算符的操作数能够被对称的处理：也就是说在+左边和右边都是正确的，比如用成员函数重载+后，写1+a，则(1).operator+(a)会报错

#### 5.2 左移运算符重载
作用：可以输出自定义数据类型。  
e.g. 
```
ostream& operator<<(ostream &cout, Person &p) {//本质：operator<<(cout, p) 简化：cout<<p
  cout << "m_A = " << p.m_A << " m_B = " << p.m_B;
	return cout;
}
```
**Notes:**  
1、cout为ostream类型，标准输出流对象；  
2、由于输出流对象cout全局只能有一个（iostream的拷贝构造函数不允许使用）因此在重载左移运算符时必须用引用传递cout；  
3、为了满足链式编程，需要使重载函数返回cout，这样才能实现连续的<<；  
4、重载运算函数的形参顺序不可改变，因为其对应着编译器简化后的运算关系； 
5、成员函数重载<<运算符，无法实现cout在左侧，因此只能利用全局函数重载左移运算符。

#### 5.3 递增运算符重载
作用：通过重载递增运算符，实现自己的整型数据。 

**重载前置递增：**  
e.g.
```
MyInteger& operator++() {//先++后返回
		m_Num++;
		return *this;//返回对象本身，这样多次++可以对同一个对象进行
	}
```

**重载后置递增：** 
e.g.
```
	MyInteger operator++(int) {//先返回后++
		MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值
		m_Num++;
		return temp;
	}
```

**return this和return *this的区别：** 
1、this是指向自身对象的指针，*this是自身对象； 
2、return *this返回的是当前对象的克隆或者本身（若返回类型为值类型，则是克隆，若返回类型为引用类型，则是本身）；return this返回当前对象的地址（指向当前对象的指针）。

**Notes:** 
1、由于编译器必须能够识别出前置与后置运算符，人为规定用`operator++()`和`operator–-()`重载前置运算符，用`operator++(int)`和`operator–-(int)`重载后置运算符;  

2、前置递增必须返回的是类的引用，这是因为如果返回类的值，则++(++a)虽然打印的是正确的结果，但对a实际上只做了一次前置递增，由于第一次++之后返回的是一个新的对象，第二次递增是对新对象进行的；因此返回引用是为了对一个数据进行递增；  

3、后置递增必须返回的是类的值，因为重载函数中返回的是局部变量，局部变量在函数运行结束后即释放，不能返回它的引用； 

4、在做后置递增运算符重载时，左移运算符重载传入的类对象必须要以值传递的方式传入，这是因为在后置递增时，返回的是一个局部变量，用值方式才能接受一个局部变量； 

#### 5.4 赋值运算符重载
赋值运算符operator=是C++编译器自动添加的函数，其作用是为属性进行值拷贝。 
但当我们进行浅拷贝(p2=p1)时，利用析构函数释放堆区数据会发生重复释放问题。因此需要进行赋值运算符重载。
```
Person& operator=(Person& p) {
		//编译器提供浅拷贝：m_Age = p.m_Age;
		if (m_Age != NULL) {//如果需要拷贝的对象存在堆区数据，则清空
			delete m_Age;
			m_Age = NULL;
		}
		m_Age = new int(*p.m_Age);//重新在堆区开辟一个区域，值与p.m_Age相同
		return *this;//以引用形式返回对象本身 
	}
```
**Notes:**  
1、赋值运算符重载的本质：`a.operator=(b)` => a = b 
2、最终将函数返回对象本身，且以引用形式返回是为了实现a=b=c的链式结构； 

#### 5.5关系运算符重载
重载关系运算符，可以让两个自定义类型对象进行对比操作
```
bool operator==(Person & p){
	if (this->m_Name == p.m_Name && this->m_Age == p.m_Age){
		return true;
	}
	else{
		return false;
	}
}
```

#### 5.6 函数调用运算符重载
函数调用运算符 () 可以重载，又称为仿函数 

### 6、继承
#### 6.1 基本语法
继承允许我们依据另一个类来定义一个类,这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。 
这个已有的类称为基类（父类），新建的类称为派生类（子类）。 

继承的语法：`class derived-class: access-specifier base-class`

#### 6.2 继承方式 
继承方式包括：公有继承(private)、保护继承(protected)、私有继承(private) 

1、父类为private，则子类任何一种继承方式都不可以访问； 
2、公有继承：父类是公共/保护，子类相同； 
3、保护继承：父类是公共/保护，子类均变为保护； 
4、私有继承：父类是公共/保护，子类均变为私有。

#### 6.3 继承中的对象模型
父类中所有非静态成员属性都会被子类继承，包括私有成员属性在内，只是被编译器隐藏了。

查看C++类的内存分布：`cl /d1 reportSingleClass类名 文件名`  

#### 6.4 继承中构造和析构的顺序
构造顺序：父类构造->子类构造
析构顺序：子类析构->父类析构

#### 6.5 继承同名成员处理方式
背景：s是Son类的一个实例，Son类继承自Base类且两者都有m_A和func()成员，Base类存在func(int a)的函数重载  
同名成员属性和函数的处理： 
1、子类对象可以直接访问到子类中同名成员:`s.m_A` `s.func()`  
2、子类对象加作用域可以访问到父类同名成员：`s.Base::m_A` `s.Base::func()`  

**Notes:** 
当子类与父类拥有同名的成员，子类会隐藏父类中所有版本（重载）的同名成员，需要加父类的作用域访问父类中被隐藏的同名成员：`s.Base::func(10)`，即调用父类的所有同名成员必须加作用域。


#### 6.6 继承同名静态成员处理方式
静态成员和非静态成员出现同名，处理方式基本一致 
静态成员的访问有两种方法：通过对象访问、通过类名访问 
具体如下（静态成员函数同）： 
对象访问：`s.m_A` `s.Base::m_A` 
类名访问：`s::m_A` `Son::Base::m_A`（第一个::指通过类名方式访问，第二个::指在Base作用域下的属性

#### 6.7 多继承
语法：`class subclass: 继承方式 superclass1, 继承方式 superclass2` 
多继承可能会引发父类中有同名成员出现，需要加作用域区分

#### 6.8 菱形继承
菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义；利用虚继承可以解决菱形继承问题 
虚继承底层的实现：两个类的继承不再继承数据而是继承2个指针，指针通过相应的偏移量找到唯一一个数据 

### 7、多态
#### 7.1 多态的基本概念
多态分为两类： 
**静态多态：函数重载**和**运算符重载**属于静态多态，复用函数名 
**动态多态：**派生类和虚函数运行时多态(c++所指的多态大多是动态多态)

静态多态和动态多态的区别： 
静态动态（函数地址早绑定）在编译阶段确定函数地址
动态多态（函数地址晚绑定）在运行阶段确定函数地址  

动态多态满足的条件： 
1、有继承关系 2、子类**重写**父类的虚函数

动态多态的使用：当父类的指针或者引用指向子类的对象时，发生多态

**Notes:** 
1、C++自动实现父类和子类之间的类型转换，不需要强制类型转换
2、重写指重新写的函数与原函数返回值类型、函数名、参数列表完全相同
3、当发生动态多态时，运行期间自动为父类添加一个指针vfptr[虚函数（表）指针]，该指针指向vftable[虚函数表]，在表的内部记录着虚函数的地址 （&Animal::speak)；在子类中会继承这个指针，但由于针对虚函数进行了重写，因此的虚函数的地址被覆盖，变为(&Cat::speak) 

#### 7.2 计算机类实例
实际开发中提倡开闭原则：对扩展进行开放，对修改进行关闭 
多态的优点： 
1、组织结构清晰（抽象类+实现类），各司其职，哪里有问题改哪里 
2、可读性强 
3、对前期和后期的可扩展性以及可维护性好，不用对原代码进行修改，只需追加 
```
//实现计算器抽象类
class AbstractCaculator {
public:
	int m_Num1;
	int m_Num2;
	virtual int getResult() {
		return 0;
	}
};
//加法计算器类
class AddCaculator :public AbstractCaculator {
public:
	int getResult() {
		return m_Num1 + m_Num2;
	}
};
//测试实例
void test01() {
	AbstractCaculator* abc = new AddCaculator;
	abc->m_Num1 = 10;
	abc->m_Num2 = 10;
	cout << abc->m_Num1 << " + " << abc->m_Num2 << " = " << abc->getResult() << endl;
	delete abc;
}
```

#### 7.3 纯虚函数和抽象类
纯虚函数语法：`virtual 返回值类型 函数名（参数列表） = 0;`（=0是说明符） 
只要类中有一个纯虚函数，就称这个类为抽象类  

**Notes:** 
1、抽象类无法实例化对象 
2、抽象类只能作为父类，其子类必须重写抽象类的纯虚函数，否则子类也无法实例化对象； 
3、虽然抽象类无法实例化，但可以通过引用或指针指向子类对象的方法访问虚函数； 
4、子类重写的虚函数最好也写上virtual（虽然加不加功能一样），这样表示更清晰，能一眼看出是对父类纯虚函数的重写，可读性强。

#### 7.4 虚析构和纯虚析构









---
