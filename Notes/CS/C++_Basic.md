# Basic：

---

## 一、基础
**打印和基本框架:**  
`cout<<...<<...<<endl`用于打印内容，并进行换行，如果没有endl则不换行且继续打印   
`system('pause')` `system('PAUSE')`用于等待用户信号，在控制台输出 “请按任意键继续...”，由于dos命令不区分大小写，因此两者作用相同

**输入：**   
`cin >> ...`表示等待输入，赋值给...   

**常量与变量:**   
常量与变量不同，常量不可更改，可用`#define`和`const`定义   

**标识符命名规则：**   
1.标识符不可以为关键字；  
2.可由字母数字和下划线构成，第一个字符只能是字母或下划线；  
3.标识符区分大小写。  

**运算符：**   
(2)递增递减：num++和++num的区别在于，在表达式中++num是先算表达式再自加的，而num++相反。   
(3)三目运算符
`f1 ? f2 : f3;`判断f1，若为True返回f2，若为False返回f3，注意该运算符通常用于赋值给一个变量      
(4)`rand()%100`生成0-99的随机数，需要添加随机种子，避免伪随机情况`srand((unsigned int)time(NULL))`   

---

## 二、数据类型   
存在意义：给变量分配合适的内存空间   
用`sizeof()`可以得到数据类型所占的内存大小，单位为字节       
**1、整型：**   
short(2byte) 范围：-32768到32767 若超出右边界，则从左边界继续计数（物极必反）   
int(4byte) 范围：-2^31到2^31-1   
long(4byte) 范围：-2^31到2^31-1   
long long(8byte) 范围：-2^63到2^63-1   
**2、实型：**   
float(4byte) 范围：7位有效数字    
double(8byte) 范围：15~16位有效数字   
**Note:**   
1.默认情况下，C++中输出一个小数只会输出6位有效数字；   
2.科学计数法，在数字整数部分后面加e；   
3.C++中默认小数为double类型，通常在小数后加f表示数字是单精度的。   
**3、字符型：**   
char(1byte)   
**Note:**   
1.字符型变量存放的是ASCII码，0-31位控制型字符，32-126位键盘上存在的字符；   
2.必须用单引号创建字符型变量；   
3.(int)ch可以输出字符所对应的ASCII码。   
**4、字符串型：**    
输出格式：   
(1)`char str[]="default"`注意加[],字符串用双引号包含字符串内容   
(2)`string str2 = "default2"`最好加上`#include <string>`   
**5、布尔型：**   
bool(1byte)   
**6、转义字符:**   
`\t`用于输出的整齐。作用实际上是填充原字符至8个字符，不足则补空格至8位，为8则加8个空格，超过了就按8为周期重新算。

---

## 三、程序流程结构   
C/C++支持顺序结构、选择结构、循环结构   
### 1、选择结构：   
(1)if:略      
(2)switch:
```   
switch(flag){
    case a:f1;break;
    case b:f2;break;
    default:f3;break;
}
```
**Note:**   
1.switch的flag只能为整型或者字符，不可以为区间，而if可以   
2.switch比if效率高

### 2、循环结构：   
(1)do...while是先执行代码块再进行while的判断，所以代码块至少执行一次；而while会先判断条件是否满足。   
(2)`for(;;){}`和`while(1){}`的效果相同   
(3)`for(f1;f2;f3){}`for循环中f1只执行一次   

**3、其他**   
(1)break用于跳出一层循环；continue用于跳过本次循环，直接进行下一次循环；   
(2)goto语句用于跳转到指定标志的地方，会跳过中间的部分。

---

## 四、数组   
### 1、一维数组：   
一维数组的定义方法：   
数据类型 数组名[数组长度];     
数据类型 数组名[数组长度]={值1，值2...};  //如果值的数量少于数组长度则将数据未赋值部分设为0      
数据类型 数组名[]={值1，值2...};   
**Notes:**   
(1)数组的各个元素都放在连续的内存空间中；   
(2)数组中每个元素都具有相同的数据类型，和定义的数组类型一致；  
(3)定义数组时必须要有初始长度；   
(4)如果定义数组的方法为`int arr[]={...}`，则可以用`sizeof(arr)/sizeof(arr[0])`来求数组的元素，如果给定数组长度，则不可以使用；   
(5)如果打印数组的名字arr，和打印&arr[0]结果是一样的；   
(6)**数组名是一个常量，是不能被修改的左值。** 利用数组名可以查看数组的内存空间和首地址。而如果需要查看除首元素外某个数组元素的地址，需要加&。note:arr=&arr=&arr[0]     

### 2、二维数组：   
二维数组的定义方法：  
数组类型 数组名[行数][列数];   
数组类型 数组名[行数][列数]={{1,2,},{3,4}};   
数组类型 数组名[行数][列数]={1,2,3,4};    
数组类型 数组名[][列数]={1,2,3,4};   
**Notes:**   
(1)利用数组名可以查看二维数组的内存空间，也可以获取二维数组的首地址。
(2)利用`sizeof(arr)/sizeof(arr[0])`可以提取行数，利用`sizeof(arr[0])/sizeof(arr[0][0])`可以提取列数。

---

## 五、函数
**函数声明：**   
提前告诉编译器函数的存在。函数的声明可以写多次，但定义只能有一次。   
**分文件编写：**   
1、创建头文件，在头文件中对函数进行声明。  
2、创建函数源文件，对函数进行定义，同时#include相应的头文件。   

---

## 六、指针      
**定义指针：**     
```
int a = 10;
int *p;
p = &a;
//一步完成：
//int *p=&a
```
**使用指针：**   
```
int a = 10;
int *p = &a;
*p = 1000;
//此时通过给*p赋值，修改了a的值
```
**空指针：**   
`int *p = NULL;`   
指向内存中编号为0的空间的指针称为空指针。作用主要是用于**初始化指针变量**，初始化指针属于程序员的素养。   

**野指针：**   
```
int *p = (int*)0x1100;
cout << *p << endl; //报错：（野指针异常）读取访问权限冲突
```
指针变量指向非法的内存空间称为野指针。   

### 1、const修饰指针（常量指针）：
```
const int* p = &a;
p = &b;//正确
*p = 20;//报错：表达式必须为可修改的左值
```   
**指针的指向可以修改，但指针指向的值不可以被修改。**   
记忆方法：const在int*前，const修饰的是指针p指向的内容，也就是说指针指向的内容不能随便修改，所以叫（只能指向）常量（的）指针   

### 2、const修饰常量（指针常量）：  
```
int * const p = &a;
p = &b;//报错：表达式必须为可修改的左值
*p = 20;//正确
```
**指针的指向不可以修改，但指针指向的值可以修改。**   
记忆方法：const在p前，所以const修饰的是指针本身，指针的作用就是指向，而现在指针不能随便指向，丧失基本作用，指针也就只能沦为指针常量   

### 3、const修饰指针和常量:   
`const int * const p = &a;`   
指针的指向和指针指向的值都不可以被修改。   

**Notes:**   
1、星号的作用是**解引用**，通过解引用可以找到指针变量所指向的内存，同时可以修改该内存；而&的作用是**取地址** ；                
2、32位操作系统下，所有指针都占4个字节，如一块连续的内存空间，用指针访问可以发现每个元素的地址依次加4；64位操作系统下，所有指针都占8个字符。   
3、空指针指向的内存不可以被访问。实际上0-255之间内存编号都是系统占用的，均不可以被访问。   
4、当我们为函数传入数组时，形参位置传入的实参应是数组的首地址，形参类型为指向数组元素类型的指针，可以写*arr或arr[]。因为不能拷贝数组，无法用值传递的方法传入数组，所以这里用的是地址传递。   

---

## 七、结构体   
### 1、结构体：   
结构体属于用户自定义的数据类型。声明结构体类型仅仅是声明了一个类型，**系统并不为之分配内存**。   
结构体的定义：**struct 结构体名 { 结构体成员列表 }**    
通过结构体创建变量的方法：   
1、struct 结构体名 结构体变量;   
2、struct 结构体名 结构体变量 = { 各个成员对应的值(value) };   
3、定义结构体同时顺便创建结构体变量：struct 结构体名 { 结构体成员列表 } 结构体变量;    

### 2、结构体数组：   
将多个自定义的结构体变量存放在数组中。   
结构体数组的定义：**struct 结构体名 数组名[元素个数] = {}**

### 3、结构体指针
定义方法：**结构体名* 结构体指针 = &结构体变量**   
此时该结构体指针指向该结构体变量，可以利用指针访问结构体变量中的数据。   

### 4、结构体嵌套：   
在一个结构体中包含另一个结构体作为成员：必须以级联方式逐级找到最底层成员再访问。      

### 5、结构体作为参数进行传递：   
传递方式：   
1、**值传递**:用结构体变量作为形参，不会影响相应实参结构体的值，参数传递时会把实参的一份副本传给形参；
```
void print_structure_value(student s) {
    s.name = "bcd";  
    cout << s.name << endl;
}
```  
2、**引用传递**:函数中用结构体数组或结构体指针作为形参，结构体变量的地址作为实参。此时在函数中修改结构体的内容会影响实参结构体的值。因为只复制了结构体首地址给函数的实参，因而**有较高的传递效率**。如果不想改变原实参中的结构体，可以在形参前加const（变为常量指针）。   
```
void print_structure_address(student* s) {
  	s->name = "bcd";
  	cout << s->name << endl;
}
```
**Notes:**   
1、利用 ‘.’ 运算符直接可以访问结构体变量的属性：**结构体变量.属性**；利用 ‘->’ 可以访问结构体指针内的属性:**结构体指针->属性**；实际上，**结构体指针->属性** 相当于**(*结构体指针).属性**，注意(*指针)一定要括起来 。   
```
//e.g.
s1 = {"abc", 1, 2};
s2[2] = {{"def",3,4},{"ghj",5,6}};
student* p1 = &s1;
student* p2 = s2; //结构体数组可以用数组名表示首元素地址
cout << p1->name << endl;
cout << p2->name << endl;
```
2、无名结构体通常用于函数内部。当只需要一个结构体变量，而不需要使用该结构体定义更多其他的变量时才能使用无名结构体；   
3、声明结构体类型仅仅是声明了一个类型，系统并不为之分配内存。只有当使用这个类型定义了变量时，系统才会为变量分配内存。所以在声明结构体类型的时候，不可以对里面的变量进行初始化；   
4、嵌套在结构体内的结构体需要定义在前面；   
5、`struct a {} a1;`和`typedef struct b {} b1;`其中a1和b1的种类不同，a1为结构体变量，而b1为一种结构体类型，相当于`struct b` 。    
6、如果将函数的形参部分是结构体指针，如`BOOKS* abs`，则在该函数下使用结构体指针变量`abs`就代表了该结构体的地址，而不用再写`&abs`。   
